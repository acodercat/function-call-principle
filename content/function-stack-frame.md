# 函数栈帧

> 当一个函数在运行时，需要为它在`堆栈`中创建一个`栈帧`（stack frame）用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。

**本节的示意图我们通过颜色区分调用者与被调用者的栈帧，蓝色表示被调用者，绿色表示调用者。**

## 创建栈帧

通常用一个叫做`栈基址`（bp）的寄存器来保存正在运行函数栈帧的`开始地址`，由于`栈指针`（sp）始终保存的是栈顶的地址，所以`栈指针`保存的也就是正在运行函数栈帧的`结束地址`。

![](https://image.coder.cat/stack3.png)

> 每次发生函数调用时都要修改`栈基址`（bp）使它保存新栈帧的`开始地址`，这将导致它被覆盖。因此我们可以利用之前讲到的`寄存器的保存与恢复`使用栈来对`栈基址`进行保存与恢复。



在一开始`栈基址`和`栈指针`都分别指向调用者栈帧的`开始地址`和`结束地址`，创建时首先将调用者栈帧的`开始地址`也就是此时的`栈基址`压栈保存，由于`栈基址`是`被调用者保存`寄存器，所以它存放在被调用的栈帧中。

栈变化过程：

![](https://image.coder.cat/stack18.png)



随后将`栈基址`（bp）修改成此时`栈指针`（sp）的值，使这它们都指向同一个位置（下面左图），如果被调用函数还需要栈空间，那么它可以继续把`栈指针`（sp）向低地址移动来分配空间（下面右图），最终`栈基址`和`栈指针`又分别指向了`被调用者`栈帧的`开始地址`和`结束地址`。

栈变化过程：

![](https://image.coder.cat/stack19.png)



栈帧中存储了函数参数、返回地址、保存的寄存器、局部变量，因此完整的栈结构可能像下面这样：



![](https://image.coder.cat/stack20.png)

**图中各个部分说明：**

* 函数参数（arguments）

  在`X64`中如果函数参数超过6个，前6个通过寄存器进行传递，其余参数则通过栈来进行参数传递，当少于等于6个或没有参数时，这个时候该栈帧部分可以忽略。

  在需要通过栈来传递参数时，`调用函数`需要先将参数压入自己的栈帧中，然后`被调用函数`从`调用函数`的栈帧中对参数进行访问。所以图中参数部分在调用函数的栈帧中。

* 返回地址（ret addr）

  将函数参数压栈之后，需要把调用位置处的下一条指令地址压栈，以便被调用函数执行完之后可以回到原来的位置继续执行，这个地址就是返回地址。

* 保存的寄存器（saved regs）

  这里存放的是需要`被调用者`来保存的寄存器，例如`旧的栈基址`（old bp）旧保存在其中。

* 局部变量（local vars）

  这个部分是存储在栈中而不是寄存器中的局部变量，如果函数没有局部变量或局部变量都存储在寄存器中，那么该栈帧部分可以忽略。



**如果再次发生函数调用，那就重复整个创建栈帧的过程，因此对于递归函数来说和普通函数也没什么区别。**



## 销毁栈帧

> 在函数返回时会把之前给这个函数创建的栈帧`销毁`，以释放空间。

销毁时先把`栈指针`（sp）移动到此时`栈基址`（bp）的位置，此时`栈指针`和`栈基址`都指向同样的位置。

栈变化过程：

![](https://image.coder.cat/stack5.png)



现在栈顶刚好是我们在创建栈帧时保存的调用者`栈帧`的`栈基址`，现在把它出栈至`栈基址`（bp），得到下图中的栈结构：

![](https://image.coder.cat/stack7.png)

到目前位置`被调用者`的栈帧已经被销毁空间得到释放，但是函数的返回步骤并没有完，`调用者`的栈帧中还保存者`返回地址`，此时需要把`返回地址`出栈至`程序计数器`（PC）以恢复到原来的位置继续执行，返回后的栈帧：

![](https://image.coder.cat/stack6.png)





**C/C++中销毁栈帧并不会清空被销毁栈帧中的数据。**